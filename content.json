[{"title":"PipeComet","date":"2017-11-08T07:11:36.000Z","path":"2017/11/08/PipeComet/","content":"<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p> PipeComet 是在解决开放平台一系列问题的过程中不断演化的基于Jetty Continuation（Servlet 3容器也适用）的代码框架。先看看下面一张图中四个场景的演变：</p>\n<img src=\"/2017/11/08/PipeComet/1.jpg\" title=\"四个场景的演变\">\n<a id=\"more\"></a>\n<p>1．  Servlet 3以前，一次http请求就由一个容器线程完成全部处理，容器线程的生命周期取决于整个业务处理的时间（如果后端有依赖系统，例如DB，集中式缓存，外部系统service），由此可见，并发处理请求的数量在容器线程池有限的条件下，直接用容器线程数量/rt（响应时间）即可得到。而容器线程是否真的需要有那么久的生命周期?在整个事务处理过程中是否可以被回收，等到需要时在申请?<br>2．  第一部分描述中，最根本的原因就是一次http请求的资源及它的生命周期完全交由容器管理，并且和容器线程一对一绑定。如果可以将请求资源和其状态与处理线程分开，生命周期不完全由容器管理，那么问题就可以得到解决。因此有了类似于Servlet3和Jetty Continuation的模式（和DB的非Auto commit很类似），期间可以引入外部线程池来接管后端业务处理，而让前端容器线程池生命周期缩短，更专注于处理连接请求和简单的请求预处理。此时可以看到，其实是将业务处理线程池与容器线程池分离，而业务线程池中可以有更灵活和轻量的处理方式。<br>3．  第二部分中做到的是将业务处理的线程池后移，但并没有从更本上解决本系统如何不受制于后端依赖系统的稳定性及处理能力的高低的约束。因此需要引入事件驱动模型，真正的将多种异步模式引入来解决各种场景的处理，直接或者间接的降低系统资源消耗。事件驱动模型更加彻底的将状态外移，让线程资源生命周期按需申请，大大提高了本系统的资源利用率，降低对外部系统的依赖。带来的负面效应就是逻辑复杂，容错处理要求高，响应时间变慢。<br>4．  最后引入了虚拟线程池，用于在多种任务执行时共享资源，同时也通过规则设置保证在竞争的情况优先级高并且重要的任务可以优先获得资源。这样也使得业务线程池有更大的业务定制化能力在其中。</p>\n<p>下图其实是从四个角度说明了TOP的问题如何被解决，同时也简单了描述了三个组件一个模型的作用：</p>\n<img src=\"/2017/11/08/PipeComet/2.jpg\" title=\"三个组件一个模型的作用\">\n<p>每一个特性上面的黄色小框框除了Condition mode不是组件，其他都是组件，后面具体的会谈到，几个点上都有他们各自的优势，其实也就解决了TOP的基本问题，接下去就仔细的谈谈这些设计点的细节和特性。</p>\n<p>设计与实现的细节</p>\n<p>首先还是要提前说明一下，参看前面的解决问题的目标，这个框架绝对不是提高并发和降低处理时间的“良药”，解耦带来的负面效果就是系统复杂度增加，响应时间可能会加长，优势在于系统之间的依赖减弱，自身的处理能力决定因素自封闭（瓶颈可以直接根据自身业务处理资源消耗情况估计出来）。<br>四种场景</p>\n<p>整个PipeComet框架主要支持下面四种业务场景：</p>\n<img src=\"/2017/11/08/PipeComet/3.jpg\" title=\"四种业务场景\">\n<p>1．  第一种模式就是最普通的Pipe管道链模式，用管道化切割原本串行的业务逻辑，目标就是让开发者能够最小单元模块化业务逻辑，便于逻辑隔离，为服务降级，Beta发布等打好基础。（最挫的就是代码只有一个pipe，一大坨揉在了一起）<br>2．  第二种模式就是将业务线程池和容器线程池切割开来，但业务线程池的线程将会负责将后续业务阻塞式的处理完。（也许有人会说，为什么不搞成全异步模式呢，后端也通过事件回调模式来完成，这样当前业务线程池线程也可以被释放，其实这种做法在4中会说明，同时2的存在也因为很多时候后端无法做到异步化，那么往往需要采用半异步的模式，效果在于业务线程池可以做更灵活的控制，特别是加入了虚拟隔离线程池）<br>3．  第三种模式中，容器线程负责将主流程逻辑执行完毕，而并行管道将会被业务线程并行执行，执行过程中支持部分结果回写给客户端，实现并行处理的目的。容器将在最后一个业务线程处理完毕后关闭请求管道。<br>4．  第四种模式为纯粹事件驱动模式，某一个管道可以设置为条件激发的管道，此管道可以被外部事件激发（一次或者多次），最后交由外部提交结束事件的请求，结束整个请求处理。（事件如果被激发和执行一次，就是用于后端依赖系统也使可以支持异步化的场景，事件如果被激发多次执行，那么就适用于实现类似于Comet长连接Push推送结果的场景，也可以称作类RSS的数据订阅推送的长连模式）</p>\n<p>接下来看看提到的四种场景的具体流程交互图：<br>1．  Common Request(Pipe Mode)</p>\n<img src=\"/2017/11/08/PipeComet/4.jpg\" title=\"Common Request(Pipe Mode)\">\n<p>补充：PipeManager负责管道的注册管理和执行，pipe之间相互隔离（互不知道对方存在），pipe之间通过context来交互数据，同时也可以根据上一个管道执行的结果判断是否需要跳过执行当前管道的业务逻辑。总的来说，Pipe化的目的就是为了从框架结构上要求开发者细粒度切割串行的业务逻辑，同时做好逻辑隔离，便于维护和控制。</p>\n<p>2．  Asyn Request</p>\n<img src=\"/2017/11/08/PipeComet/5.jpg\" title=\"Asyn Request\">\n<p>补充说明：这种模式下会发现与前面最大的差异就是当执行到asyn类型的pipe以后，后续的管道将会交由业务线程池去执行，于此同时容器线程就被回收（生命周期缩短），业务线程池执行结束后，主动将结果回刷给客户端，并且提示框架结束请求会话，释放资源。</p>\n<p>3．  Parallel Request</p>\n<img src=\"/2017/11/08/PipeComet/6.jpg\" title=\"Parallel Request\">\n<p>补充说明：第三种模式与第一种差别在于，首先容器线程将会负责主干pipe的执行，而分支pipe将会交给业务线程池并行执行，主干执行结果和分支执行结果都会回写给客户端，当框架发现主干和所有的分支线程任务都执行完毕后，则主动关闭连接，释放资源。</p>\n<p>4．  Condition Request</p>\n<img src=\"/2017/11/08/PipeComet/7.jpg\" title=\"Condition Request\">\n<p>补充说明：Condition类型的管道，最大特点就是完全由外部事件激发管道的重复执行或者继续执行，使得传统意义上的无状态阻塞式Http请求可以转变成为较长时效性，数据可不定时回复的模式，适用于消息订阅和接收的逆向设计。（这里的逆向指的是接收端和发送端角色的设置）。</p>\n<p>上面四个场景，如果从Http请求响应上来看，有这么一种转变：即时性要求很高à即时性要求一般à即时性要求很低。从系统对后端服务提供者依赖来看，转变为：强依赖à较强依赖à弱依赖。其实最终在设计角度上来看，还是在系统的可用性和效率上寻找折中和权衡，不同场景的需求不同，是否适用取决于当前系统的瓶颈及风险可承受点的差别上。</p>\n<p>四个组件</p>\n<p>   上面流程中已经反复提到了几个起到关键作用的组件，下面就逐一的介绍这些组件的设计和实现：</p>\n<img src=\"/2017/11/08/PipeComet/8.jpg\" title=\"组件的设计和实现\">\n<pre><code>四部分组件有前后关系，同时也会相互串联，实现整体协同。\n</code></pre><p>Container Patch暂时分成3部分：Lazy Parser（通过解析请求字节流来按需解析参数，节省错误请求所带来的无谓资源解析消耗），NIO Connector（当前Jetty是采用模拟阻塞模式使用非阻塞套接字处理的，在性能上还有提升空间），Request&amp;Response Wrapper是为了支持多线程并发操作Request和Response而作的Wrapper。Container Patch是处理流程中最早使用到，且比较底层的组件。（当前Lazy Parser已经正式适用，NIO Connector的优化尚未做，Wrapper做了最简单的处理）<br>PipeManager是管道框架的核心管理者，它所控制的对象即为Pipe，Pipe是无状态的，每一个请求执行时Pipe会被传入PipeInput（包含了request,response），PipeResult和PipeContext，同时PipeContext通过ThreadLocal可以在管道之间交互信息。从原数据角度讲，Pipe体系框架中最重要的就是Pipe的三个要素：PipeInput,PipeResult,PipeContext。<br>EventKeeper是事件驱动模型的简单实现，在管道框架之后被使用，承担着管道化体系的多种异步模式事件支持，同时也可以独立成为一个事件驱动模型，内部主要处理event，其中由于和管道框架结合比较紧密，因此event中包含了pipe data和需要外部线程执行的tasks。<br>JobDispatcher是虚拟的共享线程池，可以通过设置规则来对不同类型请求分配线程资源，最终在资源共享的前提下，也有选择的预留资源，限制资源，差别化分配资源。</p>\n<p>LazyParser</p>\n<p>目标：通过按需解析Http请求字节流，最小化无效请求资源解析带来的损耗。LazyParser设计实现上并不复杂，但是在解析过程中如何合理利用receive buffer来逐段分析数据成为实现的最重要的细节点。（具体可以参看LazyParser代码）</p>\n<img src=\"/2017/11/08/PipeComet/9.jpg\" title=\"LazyParser\">\n<p>PipeManager</p>\n<p>目标：通过框架约束和管理开发中业务逻辑模块化，串行处理业务隔离耦合度小，最终实现服务降级，Beta发布，异步消息。<br><img src=\"/2017/11/08/PipeComet/10.jpg\" title=\"PipeManager\"></p>\n<p>补充说明：不论是简单的同步管道链执行，还是穿插多种类型的异步管道链执行，从结构上来看都是统一的，唯一的差别就是是否会创建事件，交由外部执行，同时分支执行完毕后如何回归，并且最终所有分支执行完后结束会话，释放请求资源。（这里主要用了一个计数器来保证分支和主干在执行顺序不定的情况下依然可以根据情况提交接受请求，期间业务线程之间共享了原来单线程的ThreadLocal变量，因此也存在着部分风险）</p>\n<p>Event Keeper</p>\n<p>目的：Event Keeper就是一个简化的事件驱动模型，用于支撑管道框架的三种异步请求处理。<br>Event当前的状态迁移图如下：</p>\n<img src=\"/2017/11/08/PipeComet/11.jpg\" title=\"Event Keeper\">\n<p>有主动被调用切换的两种状态（complete和invoke），complete表示当前执行一次立刻结束，invoke表示当前执行一次，且保存状态继续等待外部激发。timeout状态属于被动激发，必须通过后台循环检测状态才能够激发（这点在后面系统设计实现分享点滴里面会有说明如何高效的实现被动状态变更检测）</p>\n<img src=\"/2017/11/08/PipeComet/12.jpg\" title=\"Event Keeper\">\n<p>补充说明：对于立即需要执行的事件（complete,invoke）都直接将任务投递到立即执行的队列中，避免在状态队列中扫描带来的消耗。Complete和invoke通过回调系统实现的默认监听器主动实现状态变更操作，而timeout则采用较为高效的处理方式（后续设计分享中会提到）。</p>\n<p>Virtual ThraedPool</p>\n<p>目的：虚拟共享线程池为了线程资源统一管理，在共享的前提下也能够通过设置分配规则在资源竞争时有差别的限制，保留及分配资源。<br><img src=\"/2017/11/08/PipeComet/13.jpg\" title=\"Virtual ThraedPool\"></p>\n<p>其中，Check resource avaliable在后面这张图中会表现的很清楚。当前支持的规则模型为：leave和limit两种，leave表示为某一类请求预留多少线程资源独享，limit表示在整个线程池中，此类请求最大所占的资源数量。当资源不足是被压入队列等待资源释放时，当前设计同样考虑了最小代价最快的得到资源可分配通知，避免反复循环检查和出入队列。<br>下图是check resource时的逻辑控制图：</p>\n<img src=\"/2017/11/08/PipeComet/14.jpg\" title=\"Check resource avaliable\">\n<p>设计分享</p>\n<p>EventKeeper</p>\n<p>线程轮询或空转是CPU最大的敌人</p>\n<p>Event一共有四个状态：init，complete，invoke，timeout。迁移如下图：<br><img src=\"/2017/11/08/PipeComet/15.jpg\" title=\"Event一共有四个状态：init，complete，invoke，timeout\"></p>\n<p>接着来看看怎么一步一步的改变一些想法：<br><img src=\"/2017/11/08/PipeComet/16.jpg\" title=\"接着来看看怎么一步一步的改变一些想法\"></p>\n<p>开始的时候用最简单和常规的思路：Event Producer将事件丢入队列，一个或者多个Thread采用block的方式去争夺Queue中的事件，判断事件状态，来决定是否丢入线程池执行。<br>问题：<br>1.需要立即执行的任务（入队列时已经是complete,invoke,timeout状态）混在等待状态变更的队列中，执行效率较慢。<br>2.Event状态如果长久不变更，会被反复读取并塞回去。</p>\n<p>优化后结构：<br><img src=\"/2017/11/08/PipeComet/17.jpg\" title=\"优化后结构\"></p>\n<p>改变：将立即执行的任务与等待外部状态变更的队列分割开来，事件在入队列前就被区分对待，在Executable Queue中的事件就会被简单执行，不做任何判断，而Queue中的事件如果发生变化，线程就将事件迁移到Executable Queue。这样解决了上面提到的第一个问题，对于很多立即执行的事件消耗很小。同时状态变更队列中只剩下两种状态的事件（init，invoke）但第二个问题依旧存在。</p>\n<p>接着在继续优化后的结果如下：<br><img src=\"/2017/11/08/PipeComet/18.jpg\" title=\"接着在继续优化后的结果如下\"><br>改变：<br>如何减少队列由于要检查状态不断地读取和插入操作？（下面描述是递进的）<br>A． 单线程能够在大队列下依旧能够高效处理。（poll就可以被peek替换或者用Iterator直接轮询）<br>B． Invoke事件的变迁往往是外部主动激发，因此可以通过对event附加上listener来让外部激发时主动做出对应的action（在两个队列中迁移event）。<br>C． 此时对于Thread1来说需要做的就是检查队列里面所有的event是否超时。最高效的策略：入队列时即按照超时时间排序，每次检测从头开始，发现当前事件已经不在超时，就无需继续检查后续链，同时用condition来await到最近一个timeout的时候，防止无用循环检查。（如果有较小的timeout event入队列将会唤醒等待）<br>具体可以参看源码。<br>         总结来说：<br>1．  能够做出判断的操作，不要用复杂的轮询状态方式来做，直接激发事件处理机制。<br>2．  将事件状态迁移分成主动迁移和被动迁移两部分，主动迁移通过在创建事件时增加listener，在主动迁移时调用listener去做后台的一些操作（框架负责调用，业务方无需了解后续状态迁移和Action）。<br>3．  被动迁移部分根据其特性有效地做排序（在少量数据时可能反而有损耗），检查时根据顺序检测，用规则减少各种无效的校验。</p>\n<p>虽然是事件驱动的一些简单的设计，但是可以适用于松散模式下的状态检查设计。</p>\n<p>LazyParser</p>\n<p>节省资源是海量处理最基本的要求</p>\n<p>问题：每一次Http请求是否都需要将所有的字节流收取完毕后才执行业务？</p>\n<p>处理方式：如果能够边解析边执行，效率更高。加入串行化逻辑被切割为（A,B,C,D四个管道顺序执行），其中A管道执行时只需要a参数，如果通过解析字节流发现a已经解析到，那么此时可以停止解析后续的字节流。</p>\n<p>优点：</p>\n<ol>\n<li>如果发现a参数已经在A处理中被认为无效请求，那么后续字节流将不在接受，同时可以节省解析字节流的时间和内存消耗。</li>\n<li>外部网络状况通常会产生慢连接，此时数据包接收速度较慢，如果可以变解析边处理可能可以减少响应时间。<br>开放平台每天十几亿的调用量，每减少一些无效请求的消耗，每提高一点慢连接带来的损耗都能够节省不少资源。</li>\n</ol>\n<p>LazyParser结构在上面组件介绍部分有说，而具体实现也主要是在字节流上的一些处理，参看代码。</p>\n<p>注意点：</p>\n<p>Continuation开发过程中，很重要的就是要了解整个Continuation的生命周期，以及Request和Response的生命周期，当Continuation结束后如果还依旧使用request或者response就会出现各种问题，同时在多线程并发+事件驱动模式下，更要注意回收自身ThreadLocal中的内容。整个框架中就是帮开发人员屏蔽各种异步请求事件驱动处理细节和资源管理细节。</p>\n<p>最终结论：<br>1， 异步模式和同步模式，对性能上没有损耗。<br>2， 引入事件驱动模型后，对性能上也没有损耗。<br>3， 事件驱动模型也满足了多种业务场景的需要（并行的管道执行，串行管道执行，异步管道执行，以及notify的需要）。<br>4， 业务线程池的引入真正的可以做到服务的隔离，质量好的isp不会受到质量差的isp的影响。</p>\n<p>后续工作</p>\n<p>1．  Jetty自身NIO Connector的优化</p>\n<ol start=\"2\">\n<li>PipeComet的Condition模式下来实现对外Http Notify，并得到单机connection和active connection的测试最大值。</li>\n</ol>\n<p><code>转自https://blog.csdn.net/cenwenchu79/article/details/6450427</code></p>\n","categories":[],"tags":[{"name":"PipeComet","slug":"PipeComet","permalink":"http://damifan.github.io/tags/PipeComet/"},{"name":"java","slug":"java","permalink":"http://damifan.github.io/tags/java/"},{"name":"开放平台","slug":"开放平台","permalink":"http://damifan.github.io/tags/开放平台/"}]},{"title":"IoC与AOP的那点事儿","date":"2017-11-02T06:20:06.000Z","path":"2017/11/02/IoC与AOP的那点事儿/","content":"<h2 id=\"IoC\"><a href=\"#IoC\" class=\"headerlink\" title=\"IoC\"></a>IoC</h2><p>控制反转(Inversion of Control)是OOP中的一种设计原则,也是Spring框架的核心.大多数应用程序的业务逻辑代码都需要两个或多个类进行合作完成的,通过IoC则可以减少它们之间的耦合度.</p>\n<h2 id=\"实现方法\"><a href=\"#实现方法\" class=\"headerlink\" title=\"实现方法\"></a>实现方法</h2><p>IoC的主要实现方法有两种,依赖注入与依赖查找.</p>\n<p>依赖注入 : 应用程序被动的接收对象,IoC容器通过类型或名称等信息来判断将不同的对象注入到不同的属性中.<br><a id=\"more\"></a><br>依赖注入主要有以下的方式:</p>\n<ul>\n<li>基于set方法 : 实现特定属性的public set()方法,来让IoC容器调用注入所依赖类型的对象.</li>\n<li>基于接口 : 实现特定接口以供IoC容器注入所依赖类型的对象.</li>\n<li>基于构造函数 : 实现特定参数的构造函数,在创建对象时来让IoC容器注入所依赖类型的对象.</li>\n<li>基于注解 : 通过Java的注解机制来让IoC容器注入所依赖类型的对象,例如Spring框架中的@Autowired.</li>\n<li>依赖查找 : 它相对于依赖注入而言是一种更为主动的方法,它会在需要的时候通过调用框架提供的方法来获取对象,获取时需要提供相关的配置文件路径、key等信息来确定获取对象的状态.</li>\n</ul>\n<h2 id=\"IoC的思想\"><a href=\"#IoC的思想\" class=\"headerlink\" title=\"IoC的思想\"></a>IoC的思想</h2><p>在传统实现中,我们都是通过应用程序自己来管理依赖的创建,例如下代码.<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Person &#123;</span><br><span class=\"line\">\t// 由Person自己管理Food类的创建</span><br><span class=\"line\">\tpublic void eat() &#123;</span><br><span class=\"line\">\t\tFood food = new Chicken();</span><br><span class=\"line\">\t\tSystem.out.println(&quot;I am eating &quot; + food.getName() + &quot;...&quot;);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>而IoC则是通过一个第三方容器来管理并维护这些被依赖对象,应用程序只需要接收并使用IoC容器注入的对象而不需要关注其他事情.<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Person &#123;</span><br><span class=\"line\">\tprivate Food food;</span><br><span class=\"line\">\t// 通过set注入</span><br><span class=\"line\">\tpublic void setFood(Food food) &#123;</span><br><span class=\"line\">\t\tthis.food = food;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t// Person不需要关注Food,只管使用即可</span><br><span class=\"line\">\tpublic void eat() &#123;</span><br><span class=\"line\">\t\tSystem.out.println(&quot;I am eating &quot; + this.food.getName() + &quot;...&quot;);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>通过以上的例子我们能够发现,控制反转其实就是对象控制权的转移,应用程序将对象的控制权转移给了第三方容器并通过它来管理这些被依赖对象,完成了应用程序与被依赖对象的解耦.</p>\n<h2 id=\"AOP\"><a href=\"#AOP\" class=\"headerlink\" title=\"AOP\"></a>AOP</h2><p>AOP(Aspect-Oriented Programming)即面向方面编程.它是一种在运行时,动态地将代码切入到类的指定方法、指定位置上的编程思想.用于切入到指定类指定方法的代码片段叫做切面,而切入到哪些类中的哪些方法叫做切入点.</p>\n<p>AOP是OOP的有益补充,OOP从横向上区分出了一个个类,AOP则从纵向上向指定类的指定方法中动态地切入代码.它使OOP变得更加立体.</p>\n<p>Java中的动态代理或CGLib就是AOP的体现.</p>\n<h2 id=\"案例分析\"><a href=\"#案例分析\" class=\"headerlink\" title=\"案例分析\"></a>案例分析</h2><p>在OOP中,我们使用封装的特性来将不同职责的代码抽象到不同的类中.但是在分散代码的同时,也增加了代码的重复性.</p>\n<p>例如,我们需要在两个或多个类中的方法都记录日志或执行时间,可能这些代码是完全一致的,但因为类与类无法联系造成代码重复.<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class A &#123;</span><br><span class=\"line\">\tpublic void something () &#123;</span><br><span class=\"line\">\t\t// 业务逻辑...</span><br><span class=\"line\">\t\trecordLog();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tprivate void recordLog() &#123;</span><br><span class=\"line\">\t\t// 记录日志...</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">public class B &#123;</span><br><span class=\"line\">\tpublic void something () &#123;</span><br><span class=\"line\">\t\t// 业务逻辑...</span><br><span class=\"line\">\t\trecordLog();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tprivate void recordLog() &#123;</span><br><span class=\"line\">\t\t// 记录日志...</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>接下来,我们采取两种不同方案来改进这段代码.</p>\n<p>将重复代码抽离到一个类中<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class A &#123;</span><br><span class=\"line\">\tpublic void something () &#123;</span><br><span class=\"line\">\t\t// 业务逻辑...</span><br><span class=\"line\">\t\tReport.recordLog();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">public class B &#123;</span><br><span class=\"line\">\tpublic void something () &#123;</span><br><span class=\"line\">\t\t// 业务逻辑...</span><br><span class=\"line\">\t\tReport.recordLog();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">public class Report &#123;</span><br><span class=\"line\">\tpublic static void recordLog (String ...messages) &#123;</span><br><span class=\"line\">\t\t// 记录日志...</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这样看似解决了问题,但类之间已经耦合了.并且当这些外围业务代码(日志,权限校验等)越来越多时,它们的侵入(与核心业务代码混在一起)会使代码的整洁度变得混乱不堪.</p>\n<p>使用AOP分离外围业务代码</p>\n<p>我们使用AspectJ,它是一个AOP框架,扩展了Java语言,并定义了AOP语法(通过它实现的编译器).</p>\n<p>使用AspectJ需要先安装并将lib中aspectjrt.jar添加进入classpath,下载地址.<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Something &#123;</span><br><span class=\"line\">    public void say() &#123;</span><br><span class=\"line\">        System.out.println(&quot;Say something...&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        Something something = new Something();</span><br><span class=\"line\">        something.say();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">public aspect SomethingAspect &#123;</span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 切入点,切入到Something.say()</span><br><span class=\"line\">     */</span><br><span class=\"line\">    pointcut recordLog():call(* com.sun.sylvanas.application.hello_aop.Something.say(..));</span><br><span class=\"line\">    /**</span><br><span class=\"line\">     * 在方法执行后执行</span><br><span class=\"line\">     */</span><br><span class=\"line\">    after():recordLog() &#123;</span><br><span class=\"line\">        System.out.println(&quot;[AFTER] Record log...&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>AOP解决了代码的重复并将这些外围业务代码抽离到一个切面中,我们可以动态地将切面切入到切入点.</p>\n<p>本文作者：SylvanasSun<br>原文链接：<a href=\"https://sylvanassun.github.io/2017/06/07/2017-06-07-IoC&amp;AOP/\" target=\"_blank\" rel=\"noopener\">https://sylvanassun.github.io/2017/06/07/2017-06-07-IoC&amp;AOP/</a><br>版权归作者所有，转载请注明出处</p>\n","categories":[],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://damifan.github.io/tags/Spring/"},{"name":"JAVA","slug":"JAVA","permalink":"http://damifan.github.io/tags/JAVA/"}]},{"title":"idea SpringBoot 新特性","date":"2017-09-20T06:27:52.000Z","path":"2017/09/20/idea-springBoot/","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>Intellij IDEA 2017.2.2版本针对Springboot设置了一些特性，本篇博客给搭建简单介绍一下如何使用这些特性。</p>\n<h2 id=\"Run-Dashboard\"><a href=\"#Run-Dashboard\" class=\"headerlink\" title=\"Run Dashboard\"></a>Run Dashboard</h2><p>针对Spring boot提供了Run Dashboard方式的来代替传统的run方法。下面看一下官网提供的面板结构图：<br><img src=\"https://www.jetbrains.com/idea/whatsnew/img/2017.2/idea_2017_2_spring_run_dashboard.gif\" alt=\"这里写图片描述\"></p>\n<p>是不是很炫，直接可以通过Dashboard看到Springboot的启动项目，并显示相应的端口等信息，同时还能在这里进行相应的操作。下面我们来看看如何调用出Dashboard。<br><a id=\"more\"></a><br>首先，你的项目应该是一个springboot的项目。然后进入Edit configurations，点击+号，找到springboot选项，添加一个springboot的配置。<br><img src=\"http://img.blog.csdn.net/20170823121157933?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd281NDEwNzU3NTQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"><br>然后依次配置，name，Main class（包含main方法的启动类），working directory，Use classpath of module，jre等。<br>最重要的是要合适一下下面的 Show in Run Dashboard是否勾选，如果未勾选，将其勾选。<br><img src=\"http://img.blog.csdn.net/20170823121437461?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd281NDEwNzU3NTQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n<p>这样就完成这一新特性的配置。尝试一下吧。效果与官网提供的相同。</p>\n<h2 id=\"Actuator-endpoints\"><a href=\"#Actuator-endpoints\" class=\"headerlink\" title=\"Actuator endpoints\"></a>Actuator endpoints</h2><p>经过上面的步骤启动springboot之后，你会发现在右侧出现了一个Endpoints的tab项。此项中又包含Health, Beans, 和Mappings。<br><img src=\"https://www.jetbrains.com/idea/whatsnew/img/2017.2/idea_2017_2_spring_endpoints_2.png\" alt=\"这里写图片描述\"></p>\n<p>比如Mappings可以显示出Springboot对外暴露的请求地址等信息。具体功能可自行尝试。不过，在使用此功能之前需要在pom文件中配置对应依赖。</p>\n<figure class=\"highlight plain\"><figcaption><span>xml has-numbering</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class=\"line\">            &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</span><br><span class=\"line\">            &lt;version&gt;1.2.3.RELEASE&lt;/version&gt;</span><br><span class=\"line\">        &lt;/dependency&gt;</span><br></pre></td></tr></table></figure>\n","categories":[],"tags":[{"name":"idea","slug":"idea","permalink":"http://damifan.github.io/tags/idea/"},{"name":"spring-boot","slug":"spring-boot","permalink":"http://damifan.github.io/tags/spring-boot/"}]},{"title":"MongoDB设置用户名密码及权限","date":"2017-08-25T08:30:42.000Z","path":"2017/08/25/MongoDB-Setting/","content":"<p>现在需要创建一个帐号，该账号需要有grant权限，即：账号管理的授权权限。<code>注意一点，帐号是跟着库走的，所以在指定库里授权，必须也在指定库里验证(auth)</code>。</p>\n<p>我们结下来就在admin 库中创建一个admin用户，并给他读写权限。<br>管理员用户是存在admin中system.users中<br>在<code>./mongo</code>中运行:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; use admin</span><br><span class=\"line\">switched to db admin</span><br><span class=\"line\">&gt; show collections</span><br><span class=\"line\">system.users</span><br><span class=\"line\">system.version</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure></p>\n<a id=\"more\"></a>\n<p>会列出本库的collections</p>\n<p>1.在admin库中，添加用户并授权<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">use admin;</span><br><span class=\"line\">db.createUser(</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">     user: &quot;admin&quot;,</span><br><span class=\"line\">     pwd: &quot;123456&quot;,</span><br><span class=\"line\">     roles:</span><br><span class=\"line\">     [</span><br><span class=\"line\">       &#123;</span><br><span class=\"line\">         role: &quot;readWrite&quot;,</span><br><span class=\"line\">         db: &quot;admin&quot;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">     ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  );</span><br></pre></td></tr></table></figure></p>\n<p>2.在admin库中验证,<strong>用户在那里创建，就在哪里验证！！！</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">use admin;</span><br><span class=\"line\">db.auth(&apos;admin&apos;, &apos;123456&apos;)</span><br></pre></td></tr></table></figure></p>\n<p>这样我们就完成在admin库中创建admin用户了。</p>\n<p>说明：<br>user：用户名<br>pwd：密码<br>roles：指定用户的角色，可以用一个空数组给新用户设定空角色；在roles字段,可以指定内置角色和用户定义的角色。role里的角色可以选：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Built-In Roles（内置角色）：</span><br><span class=\"line\">1. 数据库用户角色：read、readWrite;</span><br><span class=\"line\">2. 数据库管理角色：dbAdmin、dbOwner、userAdmin；</span><br><span class=\"line\">3. 集群管理角色：clusterAdmin、clusterManager、clusterMonitor、hostManager；</span><br><span class=\"line\">4. 备份恢复角色：backup、restore；</span><br><span class=\"line\">5. 所有数据库角色：readAnyDatabase、readWriteAnyDatabase、userAdminAnyDatabase、dbAdminAnyDatabase</span><br><span class=\"line\">6. 超级用户角色：root  </span><br><span class=\"line\">   // 这里还有几个角色间接或直接提供了系统超级用户的访问（dbOwner 、userAdmin、userAdminAnyDatabase）</span><br><span class=\"line\">7. 内部角色：__system</span><br></pre></td></tr></table></figure></p>\n<p>具体角色：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Read：允许用户读取指定数据库</span><br><span class=\"line\">readWrite：允许用户读写指定数据库</span><br><span class=\"line\">dbAdmin：允许用户在指定数据库中执行管理函数，如索引创建、删除，查看统计或访问system.profile</span><br><span class=\"line\">userAdmin：允许用户向system.users集合写入，可以找指定数据库里创建、删除和管理用户</span><br><span class=\"line\">clusterAdmin：只在admin数据库中可用，赋予用户所有分片和复制集相关函数的管理权限。</span><br><span class=\"line\">readAnyDatabase：只在admin数据库中可用，赋予用户所有数据库的读权限</span><br><span class=\"line\">readWriteAnyDatabase：只在admin数据库中可用，赋予用户所有数据库的读写权限</span><br><span class=\"line\">userAdminAnyDatabase：只在admin数据库中可用，赋予用户所有数据库的userAdmin权限</span><br><span class=\"line\">dbAdminAnyDatabase：只在admin数据库中可用，赋予用户所有数据库的dbAdmin权限。</span><br><span class=\"line\">root：只在admin数据库中可用。超级账号，超级权限</span><br></pre></td></tr></table></figure></p>\n","categories":[{"name":"数据库","slug":"数据库","permalink":"http://damifan.github.io/categories/数据库/"}],"tags":[{"name":"mondodb","slug":"mondodb","permalink":"http://damifan.github.io/tags/mondodb/"},{"name":"centos","slug":"centos","permalink":"http://damifan.github.io/tags/centos/"}]},{"title":"CentOS-7下安装MongoDB","date":"2017-08-24T06:25:00.000Z","path":"2017/08/24/CentOS-7下安装MongoDB/","content":"<p><strong>下载安装包</strong><br>MongoDB 提供了 linux 各发行版本 64 位的安装包，你可以在官网下载安装包。<br>下载地址：<a href=\"https://www.mongodb.com/download-center#community\" target=\"_blank\" rel=\"noopener\">https://www.mongodb.com/download-center#community</a></p>\n<img src=\"/2017/08/24/CentOS-7下安装MongoDB/mongodb_download.png\" title=\"图1 mongodb_download\">\n<a id=\"more\"></a>\n<p>下载完安装包，并解压 tgz（以下是在CentOS 7 64位安装） 。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl -O https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-3.4.7.tgz    # 下载</span><br><span class=\"line\">tar -zxvf mongodb-linux-x86_64-3.4.7.tgz                                   # 解压</span><br><span class=\"line\"></span><br><span class=\"line\">mv  mongodb-linux-x86_64-3.4.7/ /usr/local/mongodb                         # 将解压包拷贝到指定目录</span><br></pre></td></tr></table></figure>\n<p>MongoDB 的可执行文件位于 bin 目录下，所以可以将其添加到 PATH 路径中：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export PATH=&lt;mongodb-install-directory&gt;/bin:$PATH</span><br></pre></td></tr></table></figure></p>\n<p><code>&lt;mongodb-install-directory&gt;</code>为你MongoDB的安装路径。如本文的<code>/usr/local/mongodb</code>。<br><strong>eg:<code>export PATH=/usr/local/mongodb/bin:$PATH</code></strong></p>\n<p><strong>创建数据库目录</strong><br>MongoDB的数据存储在data目录的db目录下，但是这个目录在安装过程不会自动创建，所以你需要手动创建data目录，并在data目录中创建db目录。<br>以下实例中我们将data目录创建于根目录下(/)。 <code>注意：/data/db 是\nMongoDB默认的启动的数据库路径(--dbpath)。</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir -p /data/db</span><br></pre></td></tr></table></figure></p>\n<p><strong>命令行中运行 MongoDB 服务</strong><br>你可以再命令行中执行mongo安装目录中的bin目录执行mongod命令来启动mongdb服务。<br>注意：如果你的数据库目录不是/data/db，可以通过 –dbpath 来指定。<br>输入<code>./mongod</code> 显示如下即初步安装成功：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost bin]# ./mongod</span><br><span class=\"line\">2017-08-24T15:36:24.034+0800 I CONTROL  [initandlisten] MongoDB starting : pid=20694 port=27017 dbpath=/data/db 64-bit host=localhost</span><br><span class=\"line\">2017-08-24T15:36:24.034+0800 I CONTROL  [initandlisten] db version v3.4.7</span><br><span class=\"line\">2017-08-24T15:36:24.034+0800 I CONTROL  [initandlisten] git version: cf38c1b8a0a8dca4a11737581beafef4fe120bcd</span><br><span class=\"line\">2017-08-24T15:36:24.034+0800 I CONTROL  [initandlisten] allocator: tcmalloc</span><br><span class=\"line\">2017-08-24T15:36:24.034+0800 I CONTROL  [initandlisten] modules: none</span><br><span class=\"line\">2017-08-24T15:36:24.034+0800 I CONTROL  [initandlisten] build environment:</span><br><span class=\"line\">2017-08-24T15:36:24.035+0800 I CONTROL  [initandlisten]     distarch: x86_64</span><br><span class=\"line\">2017-08-24T15:36:24.035+0800 I CONTROL  [initandlisten]     target_arch: x86_64</span><br><span class=\"line\">2017-08-24T15:36:24.035+0800 I CONTROL  [initandlisten] options: &#123;&#125;</span><br><span class=\"line\">2017-08-24T15:36:24.056+0800 I -        [initandlisten] Detected data files in /data/db created by the &apos;wiredTiger&apos; storage engine, so setting the active storage engine to &apos;wiredTiger&apos;.</span><br><span class=\"line\">2017-08-24T15:36:24.056+0800 I STORAGE  [initandlisten] wiredtiger_open config: create,cache_size=903M,session_max=20000,eviction=(threads_min=4,threads_max=4),config_base=false,statistics=(fast),log=(enabled=true,archive=true,path=journal,compressor=snappy),file_manager=(close_idle_time=100000),checkpoint=(wait=60,log_size=2GB),statistics_log=(wait=0),</span><br><span class=\"line\">2017-08-24T15:36:24.650+0800 I FTDC     [initandlisten] Initializing full-time diagnostic data capture with directory &apos;/data/db/diagnostic.data&apos;</span><br><span class=\"line\">2017-08-24T15:36:24.650+0800 I NETWORK  [thread1] waiting for connections on port 27017</span><br></pre></td></tr></table></figure></p>\n<p><strong>MongoDB后台管理 Shell</strong><br>如果你需要进入MongoDB后台管理，你需要先打开mongodb装目录的下的bin目录，然后执行mongo命令文件。<br>MongoDB Shell是MongoDB自带的交互式Javascript shell,用来对MongoDB进行操作和管理的交互式环境。<br>当你进入mongoDB后台后，它默认会链接到 test 文档（数据库）：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@localhost bin]# ./mongo</span><br><span class=\"line\">MongoDB shell version v3.4.7</span><br><span class=\"line\">connecting to: mongodb://127.0.0.1:27017</span><br><span class=\"line\">MongoDB server version: 3.4.7</span><br></pre></td></tr></table></figure></p>\n<p>由于它是一个JavaScript shell，您可以运行一些简单的算术运算:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; 1+1</span><br><span class=\"line\">2</span><br><span class=\"line\">&gt; 2-2</span><br><span class=\"line\">0</span><br><span class=\"line\">&gt; 41-343</span><br><span class=\"line\">-302</span><br></pre></td></tr></table></figure></p>\n<p>现在让我们插入一些简单的数据，并对插入的数据进行检索：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; db.runoob.insert(&#123;x:10&#125;)</span><br><span class=\"line\">WriteResult(&#123; &quot;nInserted&quot; : 1 &#125;)</span><br><span class=\"line\">&gt; db.runoob.find()</span><br><span class=\"line\">&#123; &quot;_id&quot; : ObjectId(&quot;599e8515457986461206fafe&quot;), &quot;x&quot; : 10 &#125;</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure></p>\n<p>第一个命令将数字 10 插入到 runoob 集合的 x 字段中。<br><strong>MongoDb web 用户界面</strong><br>MongoDB 提供了简单的 HTTP 用户界面。 如果你想启用该功能，需要在启动的时候指定参数 –rest 。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./mongod --dbpath=/data/db --rest</span><br></pre></td></tr></table></figure></p>\n<p>MongoDB 的 Web 界面访问端口比服务的端口多1000。<br>如果你的MongoDB运行端口使用默认的27017，你可以在端口号为28017访问web用户界面，即地址为：<a href=\"http://localhost:28017\" target=\"_blank\" rel=\"noopener\">http://localhost:28017</a> 。</p>\n<img src=\"/2017/08/24/CentOS-7下安装MongoDB/mongodb_web.png\">","categories":[{"name":"数据库","slug":"数据库","permalink":"http://damifan.github.io/categories/数据库/"}],"tags":[{"name":"mondodb","slug":"mondodb","permalink":"http://damifan.github.io/tags/mondodb/"},{"name":"centos","slug":"centos","permalink":"http://damifan.github.io/tags/centos/"}]},{"title":"gallery","date":"2017-08-21T10:06:16.000Z","path":"2017/08/21/gallery/","content":"","categories":[{"name":"hexo","slug":"hexo","permalink":"http://damifan.github.io/categories/hexo/"},{"name":"插件","slug":"hexo/插件","permalink":"http://damifan.github.io/categories/hexo/插件/"}],"tags":[]},{"title":"hexo 图片推荐使用姿势","date":"2017-08-17T08:37:32.000Z","path":"2017/08/17/hexo-image/","content":"<p><strong>资源文件夹</strong><br>资源（Asset）代表 <code>source</code> 文件夹中除了文章以外的所有文件，例如图片、CSS、JS 文件等。比方说，如果你的Hexo项目中只有少量图片，那最简单的方法就是将它们放在 <code>source/images</code> 文件夹中。然后通过类似于 <code>![](/images/image.jpg)</code> 的方法访问它们。</p>\n<p><strong>文章资源文件夹</strong><br>对于那些想要更有规律地提供图片和其他资源以及想要将他们的资源分布在各个文章上的人来说，Hexo也提供了更组织化的方式来管理资源。这个稍微有些复杂但是管理资源非常方便的功能可以通过将 <code>config.yml</code> 文件中的 <code>post_asset_folder</code> 选项设为 true 来打开。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_config.yml  </span><br><span class=\"line\">post_asset_folder: true</span><br></pre></td></tr></table></figure></p>\n<p>当资源文件管理功能打开后，Hexo将会在你每一次通过 <code>hexo new [layout] &lt;title&gt;</code> 命令创建新文章时自动创建一个文件夹。这个资源文件夹将会有与这个 markdown 文件一样的名字。将所有与你的文章有关的资源放在这个关联文件夹中之后，你可以通过相对路径来引用它们，这样你就得到了一个更简单而且方便得多的工作流。<br><a id=\"more\"></a><br><strong>相对路径引用的标签插件</strong><br>通过常规的 markdown 语法和相对路径来引用图片和其它资源可能会导致它们在存档页或者主页上显示不正确。在Hexo 2时代，社区创建了很多插件来解决这个问题。但是，随着Hexo 3 的发布，许多新的标签插件被加入到了核心代码中。这使得你可以更简单地在文章中引用你的资源。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;% asset_path slug %&#125;</span><br><span class=\"line\">&#123;% asset_img slug [title] %&#125;</span><br><span class=\"line\">&#123;% asset_link slug [title] %&#125;</span><br></pre></td></tr></table></figure>\n<p>比如说：当你打开文章资源文件夹功能后，你把一个 example.jpg 图片放在了你的资源文件夹中，如果通过使用相对路径的常规 markdown 语法 <code>![](/example.jpg)</code> ，它将 不会 出现在首页上。（但是它会在文章中按你期待的方式工作）</p>\n<p>正确的引用图片方式是使用下列的标签插件而不是 markdown ：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;% asset_img example.jpg This is an example image %&#125;</span><br></pre></td></tr></table></figure></p>\n<img src=\"/2017/08/17/hexo-image/example.jpg\" title=\"This is an example image\">\n<p>通过这种方式，图片将会同时出现在文章和主页以及归档页中。</p>\n","categories":[{"name":"hexo","slug":"hexo","permalink":"http://damifan.github.io/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://damifan.github.io/tags/hexo/"},{"name":"blog","slug":"blog","permalink":"http://damifan.github.io/tags/blog/"}]},{"title":"大米饭的Blog正式创建公开！","date":"2017-08-17T06:52:18.000Z","path":"2017/08/17/damifan-blog-bulid/","content":"<p>大米饭的博客今天上线了，可以记录自己的小秘密了。</p>\n<p><img src=\"/assets/img/Koala.jpg\" alt=\"上图\"></p>\n","categories":[],"tags":[{"name":"闲聊","slug":"闲聊","permalink":"http://damifan.github.io/tags/闲聊/"},{"name":"随笔","slug":"随笔","permalink":"http://damifan.github.io/tags/随笔/"}]},{"title":"Hexo build blog","date":"2017-08-15T16:00:00.000Z","path":"2017/08/16/hexo-hello-world/","content":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a><br><a id=\"more\"></a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n","categories":[{"name":"hexo","slug":"hexo","permalink":"http://damifan.github.io/categories/hexo/"}],"tags":[{"name":"blog","slug":"blog","permalink":"http://damifan.github.io/tags/blog/"},{"name":"杂烩","slug":"杂烩","permalink":"http://damifan.github.io/tags/杂烩/"}]}]